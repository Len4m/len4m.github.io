#!/usr/bin/env node

/**
 * Script para generar servidores MCP de prueba
 * Simula la funcionalidad del creador web de MCP
 */

const fs = require('fs');
const path = require('path');

// Importar las plantillas (simulando las del proyecto)
const generateNodeJSTemplate = (config, params, securityConfig) => {
  const className = config.name.replace(/[^a-zA-Z0-9]/g, '') + 'Server';
  
  const paramDefinitions = params.map(param => {
    const cleanName = param.name.replace(/[^a-zA-Z0-9]/g, '_');
    const type = param.type === 'flag' ? 'boolean' : 'string';
    const required = param.required ? 'true' : 'false';
    const description = param.description
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t');
    
    return `    ${cleanName}: {
      type: "${type}",
      description: "${description}",
      required: ${required}
    }`;
  }).join(',\n');

  const requiredParams = params.filter(p => p.required).map(p => `"${p.name.replace(/[^a-zA-Z0-9]/g, '_')}"`);

  return `#!/usr/bin/env node

/**
 * ${config.description}
 * Generated by MCP Creator - https://github.com/modelcontextprotocol/mcp
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { 
  CallToolRequestSchema, 
  ErrorCode, 
  ListToolsRequestSchema, 
  McpError 
} = require('@modelcontextprotocol/sdk/types.js');

class ${className} {
  constructor() {
    this.server = new Server(
      { name: "${config.name}", version: "${config.version}" },
      { capabilities: { tools: {} } }
    );
    
    this.setupHandlers();
  }

  setupHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "${config.binaryName}",
          description: "${config.description}",
          inputSchema: {
            type: "object",
            properties: {
${paramDefinitions}
            },
            required: [${requiredParams.join(', ')}]
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      if (name === "${config.binaryName}") {
        return await this.executeTool(args);
      }
      
      throw new McpError(ErrorCode.MethodNotFound, \`Unknown tool: \${name}\`);
    });
  }

  async executeTool(args) {
    try {
      // Simulación de ejecución del comando
      const result = \`Executed ${config.binaryName} with args: \${JSON.stringify(args)}\`;
      
      return {
        content: [
          {
            type: "text",
            text: result
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text", 
            text: \`Error: \${error.message}\`
          }
        ]
      };
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("${config.name} MCP Server running on stdio");
  }
}

if (require.main === module) {
  const server = new ${className}();
  server.run().catch(console.error);
}

module.exports = ${className};
`;
};

const generatePythonTemplate = (config, params, securityConfig) => {
  const paramDefinitions = params.map(param => {
    const type = param.type === 'flag' ? 'boolean' : 'string';
    const required = param.required ? 'True' : 'False';
    const description = param.description
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\t/g, '\\t');
    
    return `            "${param.name}": {
                "type": "${type}",
                "description": "${description}",
                "required": ${required}
            }`;
  }).join(',\n');

  return `#!/usr/bin/env python3

"""
${config.description}
Generated by MCP Creator - https://github.com/modelcontextprotocol/mcp
"""

import asyncio
import json
import sys
from typing import Any, Dict, List, Optional

from mcp.server.models import InitializationOptions
from mcp.server import NotificationOptions, Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    CallToolRequest,
    CallToolResult,
    ListToolsRequest,
    ListToolsResult,
    Tool,
    TextContent,
)

server = Server("${config.name}")

@server.list_tools()
async def handle_list_tools() -> ListToolsResult:
    """List available tools."""
    return ListToolsResult(
        tools=[
            Tool(
                name="${config.binaryName}",
                description="${config.description}",
                inputSchema={
                    "type": "object",
                    "properties": {
${paramDefinitions}
                    }
                }
            )
        ]
    )

@server.call_tool()
async def handle_call_tool(request: CallToolRequest) -> CallToolResult:
    """Handle tool execution requests."""
    
    if request.name == "${config.binaryName}":
        return await execute_tool(request.arguments or {})
    
    raise ValueError(f"Unknown tool: {request.name}")

async def execute_tool(args: Dict[str, Any]) -> CallToolResult:
    """Execute the ${config.binaryName} tool."""
    try:
        # Simulación de ejecución del comando
        result = f"Executed ${config.binaryName} with args: {json.dumps(args)}"
        
        return CallToolResult(
            content=[
                TextContent(
                    type="text",
                    text=result
                )
            ]
        )
    except Exception as error:
        return CallToolResult(
            content=[
                TextContent(
                    type="text",
                    text=f"Error: {error}"
                )
            ]
        )

def main():
    """Run the server using stdin/stdout streams."""
    async def arun():
        async with stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="${config.name}",
                    server_version="${config.version}",
                    capabilities=server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )

    asyncio.run(arun())

if __name__ == "__main__":
    main()
`;
};

// Función principal
function generateServer(configPath, outputDir, language) {
  try {
    // Leer configuración
    const configData = fs.readFileSync(configPath, 'utf8');
    const config = JSON.parse(configData);
    
    console.log(`Generando servidor ${config.name} en ${language}...`);
    
    // Crear directorio de salida
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Generar código según el lenguaje
    let serverCode, fileName, packageFile;
    
    if (language === 'nodejs') {
      serverCode = generateNodeJSTemplate(config, config.parameters, config.securityConfig);
      fileName = 'index.js';
      
      // Crear package.json
      packageFile = {
        name: config.name,
        version: config.version,
        description: config.description,
        main: 'index.js',
        scripts: {
          start: 'node index.js'
        },
        dependencies: {
          '@modelcontextprotocol/sdk': '^0.4.0'
        }
      };
      
      fs.writeFileSync(
        path.join(outputDir, 'package.json'),
        JSON.stringify(packageFile, null, 2)
      );
      
    } else if (language === 'python') {
      serverCode = generatePythonTemplate(config, config.parameters, config.securityConfig);
      fileName = 'server.py';
      
      // Crear requirements.txt
      fs.writeFileSync(
        path.join(outputDir, 'requirements.txt'),
        'mcp>=0.4.0\n'
      );
    } else {
      throw new Error(`Lenguaje no soportado: ${language}`);
    }
    
    // Escribir archivo principal
    fs.writeFileSync(path.join(outputDir, fileName), serverCode);
    
    // Hacer ejecutable si es necesario
    if (language === 'nodejs') {
      fs.chmodSync(path.join(outputDir, fileName), 0o755);
    } else if (language === 'python') {
      fs.chmodSync(path.join(outputDir, fileName), 0o755);
    }
    
    // Crear README
    const readme = `# ${config.name}

${config.description}

## Instalación

### ${language === 'nodejs' ? 'Node.js' : 'Python'}

\`\`\`bash
${language === 'nodejs' ? 'npm install' : 'pip install -r requirements.txt'}
\`\`\`

## Uso

\`\`\`bash
${language === 'nodejs' ? 'node index.js' : 'python server.py'}
\`\`\`

## Generado por

MCP Creator - https://github.com/modelcontextprotocol/mcp
`;
    
    fs.writeFileSync(path.join(outputDir, 'README.md'), readme);
    
    console.log(`✅ Servidor generado exitosamente en: ${outputDir}`);
    return 0;
    
  } catch (error) {
    console.error(`❌ Error generando servidor: ${error.message}`);
    return 1;
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  const [,, configPath, outputDir, language] = process.argv;
  
  if (!configPath || !outputDir || !language) {
    console.error('Uso: node generate-server.js <config.json> <output-dir> <language>');
    process.exit(1);
  }
  
  const exitCode = generateServer(configPath, outputDir, language);
  process.exit(exitCode);
} 